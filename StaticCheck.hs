module StaticCheck where

-- Haskell module generated by the BNF converter

import           System.Exit                    ( exitFailure )
import           Control.Monad.State
import           Control.Monad.Except
import           Control.Monad                  ( void )
import           Data.Maybe
import           System.IO
import qualified Data.Map                      as Map
import qualified Data.Set                      as Set

import           AbsGrammar                    as Grammar
import           ErrM


-------------------------------------------------------------------------------

type Result = SCM ()

check :: Show a => Program a -> IO ()
check p = do
  let (ret, s) = runState (runExceptT $ checkProgram p) initialState
  case ret of
    Left err -> do
      hPutStrLn stderr err
      exitFailure
    _ -> return ()


-- Program --------------------------------------------------------------------

checkProgram :: Show a => Program a -> SCM ()
checkProgram (Program _ decls) = do
  checkAllDecls decls
  getFunction (Just (0, 0)) (Ident "main")
  return ()


-- Main monad -----------------------------------------------------------------

type SCM = ExceptT String (State SCState)


-- Except ---------------------------------------------------------------------

showPos :: Show a => a -> String
showPos pos = case show pos of
  ('J' : 'u' : 's' : 't' : ' ' : realPos) -> realPos
  _ -> show pos

staticCheckError :: Show a => a -> String -> SCM b
staticCheckError pos mes =
  throwError $ "StaticError at " ++ showPos pos ++ ": " ++ mes


-- State ----------------------------------------------------------------------

data ValueType = IntT | StrT | BoolT | VoidT | NoneT deriving Eq

data FuncType = FuncType ValueType [ArgT]
data ArgT = ValT ValueType | RefT ValueType


newtype FEnv = FEnv (Map.Map Ident FuncType)
newtype TEnv = TEnv (Map.Map Ident ValueType)

data SCState = SCState {
  fenv :: FEnv,
  tenv :: TEnv,
  returnType :: ValueType,
  inALoop :: Bool
}

initialState :: SCState
initialState = SCState { fenv       = FEnv Map.empty
                       , tenv       = TEnv Map.empty
                       , returnType = NoneT
                       , inALoop    = False
                       }


runOnFenvMap :: (Map.Map Ident FuncType -> a) -> FEnv -> a
runOnFenvMap f (FEnv map) = f map

runOnTenvMap :: (Map.Map Ident ValueType -> a) -> TEnv -> a
runOnTenvMap f (TEnv map) = f map

runIsolated :: SCM a -> SCM a
runIsolated x = do
  formerState <- get
  ret         <- x
  put formerState
  return ret

runInALoop :: SCM a -> SCM a
runInALoop x = do
  formerInALoop <- gets inALoop
  modify (\s -> s { inALoop = True })
  ret <- x
  modify (\s -> s { inALoop = formerInALoop })
  return ret


-- Variables ------------------------------------------------------------------

isDeclared :: Ident -> SCM Bool
isDeclared id = gets $ runOnTenvMap (Map.member id) . tenv

getType :: Show a => a -> Ident -> SCM ValueType
getType pos id = do
  maybeType <- gets $ runOnTenvMap (Map.lookup id) . tenv
  case maybeType of
    Just t -> return t
    Nothing ->
      staticCheckError pos ("Variable " ++ show id ++ " not declared.")

addVariableType :: Ident -> ValueType -> SCState -> SCState
addVariableType id t s =
  s { tenv = TEnv $ runOnTenvMap (Map.insert id t) $ tenv s }

declareVariable :: Ident -> ValueType -> SCM ()
declareVariable id type_ = modify $ addVariableType id type_


-- Functions ------------------------------------------------------------------

addFunction :: Ident -> FuncType -> SCM ()
addFunction id f =
  let addFunctionToState :: Ident -> FuncType -> SCState -> SCState
      addFunctionToState id1 f1 s =
          s { fenv = FEnv $ runOnFenvMap (Map.insert id1 f1) $ fenv s }
  in  modify $ addFunctionToState id f

getFunction :: Show a => a -> Ident -> SCM FuncType
getFunction pos id = do
  maybeF <- gets $ runOnFenvMap (Map.lookup id) . fenv
  case maybeF of
    Just f  -> return f
    Nothing -> staticCheckError pos $ "Function " ++ show id ++ " not defined"

changeReturnType :: ValueType -> SCM ()
changeReturnType t = modify (\s -> s { returnType = t })


-- Blocks ---------------------------------------------------------------------

checkBlock :: Show a => Block a -> SCM ()
checkBlock x = case x of
  Block _ blockinsts -> runIsolated $ checkAllBlockInsts blockinsts

checkAllBlockInsts :: Show a => [BlockInst a] -> SCM ()
checkAllBlockInsts x = case x of
  []       -> return ()
  bi : bis -> checkBlockInst bi >> checkAllBlockInsts bis

checkBlockInst :: Show a => BlockInst a -> SCM ()
checkBlockInst x = case x of
  DeclInst _ decl -> checkDecl decl
  StmtInst _ stmt -> checkStmt stmt


-- Declarations ---------------------------------------------------------------

checkAllDecls :: Show a => [Decl a] -> SCM ()
checkAllDecls x = case x of
  [ d ]  -> checkDecl d
  d : ds -> checkDecl d >> checkAllDecls ds

checkDecl :: Show a => Decl a -> SCM ()
checkDecl x = case x of
  FnDecl _ type_ ident args block -> do
    s <- get
    let returnType      = checkType type_
    let argDescriptions = map checkArg args
    let fType           = FuncType returnType $ map fst argDescriptions
    addFunction ident fType

    runIsolated $ do
      changeReturnType returnType
      declareArgs argDescriptions
      checkBlock block
  VarDecl pos type_ [item] -> case item of
    NoInit pos id    -> declareVariable id (checkType type_)
    Init pos id expr -> do
      let t = checkType type_
      exprT <- checkExpr expr
      unless (exprT == t) $ staticCheckError pos "Incorrect expression type"
      declareVariable id t
  VarDecl pos type_ (item : items) -> checkDecl (VarDecl pos type_ [item])
    >> checkDecl (VarDecl pos type_ items)

checkArg :: Show a => Arg a -> (ArgT, Ident)
checkArg x = case x of
  Arg _ argtype ident -> (checkArgType argtype, ident)

declareArgs :: [(ArgT, Ident)] -> SCM ()
declareArgs []                   = return ()
declareArgs ((type_, id) : args) = do
  case type_ of
    ValT t -> declareVariable id t
    RefT t -> declareVariable id t
  declareArgs args


-- Statements -----------------------------------------------------------------

checkStmt :: Show a => Stmt a -> SCM ()
checkStmt x = case x of
  Empty _            -> return ()
  BStmt _ block      -> checkBlock block
  Ass pos ident expr -> do
    declared <- isDeclared ident
    unless declared
      $ staticCheckError pos "Trying to assign value to undeclared variable"
    varT  <- getType pos ident
    exprT <- checkExpr expr
    unless (exprT == varT) $ staticCheckError
      pos
      "Trying to assign value to variable with another type"
  Incr pos ident -> do
    t <- getType pos ident
    unless (t == IntT) $ staticCheckError
      pos
      "Trying to increment variable of non-integer type"
  Decr pos ident -> do
    t <- getType pos ident
    unless (t == IntT) $ staticCheckError
      pos
      "Trying to decrement variable of non-integer type"
  Ret pos expr -> do
    returnType <- gets returnType
    when (returnType == VoidT)
      $ staticCheckError pos "Trying to return some value in a void function"
    exprType <- checkExpr expr
    unless (exprType == returnType)
      $ staticCheckError pos "Trying to return value of incorrect type"
  VRet pos -> do
    returnType <- gets returnType
    unless (returnType == VoidT)
      $ staticCheckError pos "Void return in a non-void function"
  Cond pos expr stmt -> do
    t <- checkExpr expr
    unless (t == BoolT) $ staticCheckError pos "Condition isn't a bool value"
    checkStmt stmt
  CondElse pos expr stmt1 stmt2 -> do
    t <- checkExpr expr
    unless (t == BoolT) $ staticCheckError pos "Condition isn't a bool value"
    checkStmt stmt1
    checkStmt stmt2
  While pos expr stmt -> do
    t <- checkExpr expr
    unless (t == BoolT) $ staticCheckError pos "Condition isn't a bool value"
    runInALoop $ checkStmt stmt
  SExp _ expr -> Control.Monad.void $ checkExpr expr
  Break pos   -> do
    isInALoop <- gets inALoop
    unless isInALoop $ staticCheckError pos "'break' statement outside a loop"
  Continue pos -> do
    isInALoop <- gets inALoop
    unless isInALoop
      $ staticCheckError pos "'continue' statement outside a loop"
  Print pos expr -> do
    t <- checkExpr expr
    case t of
      VoidT ->
        staticCheckError pos "Trying to print result of a void expression"
      _ -> return ()


-- Types ----------------------------------------------------------------------

checkType :: Show a => Type a -> ValueType
checkType x = case x of
  Grammar.Int  _ -> IntT
  Grammar.Str  _ -> StrT
  Grammar.Bool _ -> BoolT
  Grammar.Void _ -> VoidT

checkArgType :: Show a => ArgType a -> ArgT
checkArgType x = case x of
  ValArgType _ type_ -> ValT $ checkType type_
  RefArgType _ type_ -> RefT $ checkType type_


-- Expressions ----------------------------------------------------------------

checkExpr :: Show a => Expr a -> SCM ValueType
checkExpr x = case x of
  EVar    pos ident    -> getType pos ident
  ELitInt _   integer  -> return IntT
  ELitTrue  _          -> return BoolT
  ELitFalse _          -> return BoolT
  EApp pos ident exprs -> do
    (FuncType retType argTypes) <- getFunction pos ident
    checkArgsFromExprs pos argTypes exprs
    return retType
  EString _   string -> return StrT
  Neg     pos expr   -> do
    exprT <- checkExpr expr
    unless (exprT == IntT)
      $ staticCheckError pos "Trying to use '-' operator on non-integer value"
    return IntT
  Not pos expr -> do
    exprT <- checkExpr expr
    unless (exprT == BoolT)
      $ staticCheckError pos "Trying to use '!' operator on non-bool value"
    return BoolT
  EMul _ expr1 mulop expr2 -> do
    let pos = getMulOpPos mulop
    t1 <- checkExpr expr1
    unless (t1 == IntT)
      $  staticCheckError pos
      $  "First argument of '"
      ++ getMulOp mulop
      ++ "' operator is not an integer value"
    t2 <- checkExpr expr2
    unless (t2 == IntT)
      $  staticCheckError pos
      $  "Second argument of '"
      ++ getMulOp mulop
      ++ "' operator is not an integer value"
    return IntT
  EAdd _ expr1 addop expr2 -> case addop of
    Plus pos -> do
      t1 <- checkExpr expr1
      unless (t1 == IntT || t1 == StrT)
        $  staticCheckError pos
        $  "First argument of '"
        ++ getAddOp addop
        ++ "' operator is not an integer nor string value"
      t2 <- checkExpr expr2
      unless (t2 == IntT || t2 == StrT)
        $  staticCheckError pos
        $  "Second argument of '"
        ++ getAddOp addop
        ++ "' operator is not an integer nor string value"
      case (t1, t2) of
        (IntT, IntT) -> return IntT
        (StrT, StrT) -> return StrT
        _ -> staticCheckError pos "Trying to add integer and string values"
    Minus pos -> do
      t1 <- checkExpr expr1
      unless (t1 == IntT)
        $  staticCheckError pos
        $  "First argument of '"
        ++ getAddOp addop
        ++ "' operator is not an integer value"
      t2 <- checkExpr expr2
      unless (t2 == IntT)
        $  staticCheckError pos
        $  "Second argument of '"
        ++ getAddOp addop
        ++ "' operator is not an integer value"
      return IntT
  ERel _ expr1 relop expr2 -> do
    let pos = getRelOpPos relop
    t1 <- checkExpr expr1
    t2 <- checkExpr expr2
    case relop of
      EQU _ -> return BoolT
      NE  _ -> return BoolT
      _     -> do
        unless (t1 == IntT)
          $  staticCheckError pos
          $  "First argument of '"
          ++ getRelOp relop
          ++ "' operator is not an integer value"
        unless (t2 == IntT)
          $  staticCheckError pos
          $  "Second argument of '"
          ++ getRelOp relop
          ++ "' operator is not an integer value"
        return BoolT
  EAnd pos expr1 expr2 -> do
    t1 <- checkExpr expr1
    unless (t1 == BoolT) $ staticCheckError
      pos
      "First argument of '&&' operator is not a bool value"
    t2 <- checkExpr expr2
    unless (t2 == BoolT) $ staticCheckError
      pos
      "Second argument of '&&' operator is not a bool value"
    return BoolT
  EOr pos expr1 expr2 -> do
    t1 <- checkExpr expr1
    unless (t1 == BoolT) $ staticCheckError
      pos
      "First argument of '|| operator is not a bool value"
    t2 <- checkExpr expr2
    unless (t2 == BoolT) $ staticCheckError
      pos
      "Second argument of '||' operator is not a bool value"
    return BoolT

exprPos :: Show a => Expr a -> a
exprPos x = case x of
  EVar    pos _  -> pos
  ELitInt pos _  -> pos
  ELitTrue  pos  -> pos
  ELitFalse pos  -> pos
  EApp pos _ _   -> pos
  EString pos _  -> pos
  Neg     pos _  -> pos
  Not     pos _  -> pos
  EMul pos _ _ _ -> pos
  EAdd pos _ _ _ -> pos
  ERel pos _ _ _ -> pos
  EAnd pos _ _   -> pos
  EOr  pos _ _   -> pos


checkArgsFromExprs :: Show a => a -> [ArgT] -> [Expr a] -> SCM ()
checkArgsFromExprs _   []              []             = return ()
checkArgsFromExprs pos (type_ : types) (expr : exprs) = do
  nextArgs <- checkArgsFromExprs pos types exprs
  case (type_, expr) of
    (ValT t, e) -> do
      exprT <- checkExpr e
      unless (exprT == t)
        $ staticCheckError (exprPos e) "Incorrect type of argument"
    (RefT t, EVar pos id) -> do
      exprT <- checkExpr expr
      unless (exprT == t) $ staticCheckError pos "Incorrect type of argument"
    (_, e) -> staticCheckError
      (exprPos e)
      "Trying to pass non-reference argument as a reference"
checkArgsFromExprs pos _ _ =
  staticCheckError pos "Incorrect number of arguments"


-- Operators ------------------------------------------------------------------

getAddOp :: Show a => AddOp a -> String
getAddOp x = case x of
  Plus  _ -> "+"
  Minus _ -> "-"

getMulOp :: Show a => MulOp a -> String
getMulOp x = case x of
  Times _ -> "*"
  Div   _ -> "/"
  Mod   _ -> "%"

getRelOp :: Show a => RelOp a -> String
getRelOp x = case x of
  LTH _ -> "<"
  LE  _ -> "<="
  GTH _ -> ">"
  GE  _ -> ">="
  EQU _ -> "=="
  NE  _ -> "!="

getMulOpPos :: Show a => MulOp a -> a
getMulOpPos x = case x of
  Times pos -> pos
  Div   pos -> pos
  Mod   pos -> pos

getRelOpPos :: Show a => RelOp a -> a
getRelOpPos x = case x of
  LTH pos -> pos
  LE  pos -> pos
  GTH pos -> pos
  GE  pos -> pos
  EQU pos -> pos
  NE  pos -> pos


